import torch
from functools import lru_cache
from torch.distributions import Normal
from torchquad import set_up_backend, VEGAS

# Set up TorchQuad backend
set_up_backend("torch", data_type="float64")

vegas = VEGAS()

def matrix_power(s0, s1, f2, t):
    a = torch.tensor([[0.0, 0.0, f2],
                      [s0, 0.0, 0.0],
                      [0.0, s1, 0.0]], dtype=torch.float64)
    return torch.matrix_power(a, t)


def p0(s0, s1, f2, h, l, p, t):
    a_n = matrix_power(s0, s1, f2, t)
    if a_n[0, 2] != 0:
        return a_n[0, 2] / h
    elif a_n[1, 2] != 0:
        return a_n[1, 2] / l
    elif a_n[2, 2] != 0:
        return a_n[2, 2] / p
    else:
        return torch.tensor(float('nan'), dtype=torch.float64)


def det(s0, s1, f2, t):
    a_n = matrix_power(s0, s1, f2, t)
    if a_n[0, 2] != 0:
        return 1 / a_n[0, 2]
    elif a_n[1, 2] != 0:
        return 1 / a_n[1, 2]
    elif a_n[2, 2] != 0:
        return 1 / a_n[2, 2]
    else:
        return torch.tensor(float('nan'), dtype=torch.float64)


def distribution(variable, mu, sigma):
    dist = Normal(mu, sigma)
    return torch.exp(dist.log_prob(variable))


def fun1(mu_0, sigma_0, mu_1, sigma_1, mu_2, sigma_2, mu_3, sigma_3, h, l, p, t):  # Added Vegas-specific parameters

    h = torch.tensor(h, dtype=torch.float64)
    l = torch.tensor(l, dtype=torch.float64)
    p = torch.tensor(p, dtype=torch.float64)

    def integrand(x):

        s0, s1, f2 = x[:, 0], x[:, 1], x[:, 2]

        results = torch.zeros_like(s0)
        for i in range(len(s0)):
            p0_result = p0(s0[i].item(), s1[i].item(), f2[i].item(), h, l, p, t)
            det_result = det(s0[i].item(), s1[i].item(), f2[i].item(), t)

            print(f"Debug - s0: {s0[i]}, s1: {s1[i]}, f2: {f2[i]}, p0: {p0_result}, det: {det_result}")

            if not torch.isnan(p0_result) and not torch.isnan(det_result):
                results[i] = (distribution(s0[i], mu_0, sigma_0) *
                              distribution(s1[i], mu_1, sigma_1) *
                              distribution(f2[i], mu_2, sigma_2) *
                              distribution(p0_result, mu_3, sigma_3) *
                              det_result)

        return results.reshape(-1, 1)

    domain = torch.tensor([
        [mu_0 - 8 * sigma_0, mu_0 + 8 * sigma_0],
        [mu_1 - 8 * sigma_1, mu_1 + 8 * sigma_1],
        [mu_2 - 8 * sigma_2, mu_2 + 8 * sigma_2]
    ], dtype=torch.float64)

    result = vegas.integrate(integrand, dim=3, N=1000, integration_domain=domain)

    return result.item()

def main():
    print(fun1(9, 2, 3, 3, 1, 3, 1, 0.5, 9, 3, 1, 7))


if __name__ == "__main__":
    main()
